//
//  PerlinNoise.m
//  GameTem
//
//  Created by longminghong on 17/3/21.
//  Copyright © 2017年 longminghong. All rights reserved.
//

#import "PerlinNoise.h"

@implementation PerlinNoise

+ (instancetype)sharedInstance {
    static dispatch_once_t once;
    static id instance;
    dispatch_once(&once, ^{
        instance = [self new];
    });
    return instance;
}

// Interpolates from one value to the next, using the cosine // function to smooth the values.
- (float) interpolateCosineWithStart:(float)start
                                 end:(float)end amount:(float)amount {
    // Perform cosine interpolation, which creates a smooth transition
    // from one value to the next
    float ft = amount * M_PI;
    float f = (1 - cosf(ft)) * 0.5f;
    return start*(1-f)+end*f;
}

// Returns a random number generated by combining the components of
// the position and the random seed.
// This random number generator is guaranteed to provide the same
// results for the same inputs.
- (float) noiseAtPosition:(CGPoint)position seed:(int)seed {
    int n = (int)position.x + (int)position.y * 57 * (seed * 131);
    n=(n<<13)^n;
    return ( 1.0 - ( (n * (n * n * 15731 + 789221) + 1376312589) & 0x7fffffff)
            / 1073741824.0);
}

// Given a position, return the noise value at that position based on the noise // values of its neighbours.
- (float) smoothNoiseAtPosition:(CGPoint)position seed:(int)seed {
    
    // Get the noise values for points at the corners...
    float topLeftCorner = [self noiseAtPosition:(CGPoint){position.x-1,
        position.y - 1}
                                           seed:seed];
    
    float topRightCorner = [self noiseAtPosition:(CGPoint){position.x+1,
        position.y - 1}
                                            seed:seed];
    
    float bottomLeftCorner = [self noiseAtPosition:(CGPoint){position.x-1,
        position.y + 1}
                                              seed:seed];
    
    float bottomRightCorner = [self noiseAtPosition:(CGPoint){position.x+1,position.y + 1}
                                               seed:seed];
    
    // ... the sides...
    float leftSide =[self noiseAtPosition:(CGPoint){position.x-1, position.y}
                                     seed:seed];
    
    float rightSide = [self noiseAtPosition:(CGPoint){position.x + 1,
        position.y}
                                       seed:seed];
    float topSide = [self noiseAtPosition:(CGPoint){position.x,
        position.y - 1}
                                     seed:seed];
    
    float bottomSide = [self noiseAtPosition:(CGPoint){position.x,
        position.y + 1}
                                        seed:seed];
    
    // ... and the center.
    float center = [self noiseAtPosition:(CGPoint){position.x, position.y} seed:seed];
    
    // Merge them all together. The corners affect the result the least, // the center the most, and the sides halfway between.
    float corners = (topLeftCorner + topRightCorner +
                     bottomLeftCorner + bottomRightCorner) / 16.0f;
    
    float sides = (leftSide + rightSide + topSide + bottomSide) / 8.0f;
    
    center = center / 4.0f;
    // Return the result.
    return corners + sides + center;
}

// Given a position in the image, work out how the noise values blend // together in the image
- (float) interpolatedNoiseAtPosition:(CGPoint)position seed:(int)seed {
    int integralX = (int)position.x; int integralY = (int)position.y;
    float fractionalX = position.x - integralX; float fractionalY = position.y - integralY;
    float v1 = [self smoothNoiseAtPosition:(CGPoint){integralX, integralY} seed:seed];
    
    float v2 = [self smoothNoiseAtPosition:(CGPoint){integralX+1, integralY} seed:seed];
    float v3 = [self smoothNoiseAtPosition:(CGPoint){integralX, integralY+1} seed:seed];
    float v4 = [self smoothNoiseAtPosition:(CGPoint){integralX+1, integralY+1} seed:seed];
    float i1 = [self interpolateCosineWithStart:v1 end:v2 amount:fractionalX]; float i2 = [self interpolateCosineWithStart:v3 end:v4 amount:fractionalX];
    return [self interpolateCosineWithStart:i1 end:i2 amount:fractionalY];
}


// Calculate the value of the image at a given position by applying // Perlin noise.
- (float) perlinNoiseAtPosition:(CGPoint)position
                    persistence:(float)persistence octaves:(int)octaves seed:(int)seed {
    float total = 0.0; for(int i=0;i<=octaves-1;i++){
        int frequency = pow(2, i);
        float amplitude = pow(persistence, i);
        total += [self interpolatedNoiseAtPosition:(CGPoint)
                  {(position.x * frequency),
                      (position.y * frequency)}
                                              seed:seed * (i+1)] * amplitude;
    }
    return total;
}

// Generate an image filled with Perlin noise.
- (void) imageWithSize:(CGSize)size persistence:(float)persistence octaves:(int)octaves seed:(int) seed
            completion:(void (^)(UIImage* image))completionBlock {
    // If we don't have a completion block, immediately return // after logging an error.
    if (completionBlock == NULL) {
        NSLog(@"Error: %@ was called with no completion block, so there's no way to return the image. Provide a completion block.", NSStringFromSelector(_cmd));
        return;
    }
    // Create a background queue to run the operation on
    NSOperationQueue* backgroundQueue = [[NSOperationQueue alloc] init]; // Run the work in the background
    [backgroundQueue addOperationWithBlock:^{
        // Begin a new graphics context
        UIGraphicsBeginImageContextWithOptions(size, YES,
                                               [UIScreen mainScreen].scale);
        // Get the graphics context as a CGContextRef
        // so that we can use CoreGraphics calls later
        CGContextRef context = UIGraphicsGetCurrentContext();
        
        // For each pixel in the image, work out the value using the // Perlin noise algorithm.
        for (int x = 0; x <= size.width; x+= 1) {
            for(int y=0;y<=size.height;y+=1){
                // Work out the Perlin noise value
                // for this pixel.
                float value = [self perlinNoiseAtPosition:(CGPoint)
                               {x / size.width, y / size.height}
                                              persistence:persistence octaves:octaves
                                                     seed:seed];
                // Example of banding the output (uncomment to apply)
                /*
                 if (value > 0.5)
                 value = 0.9;
                 else if (value > 0.3)
                 value = 0.5;
                 else if (value > 0.2)
                 value = 0.3;
                 else
                 value = 0.2;
                 */
                // Once we have the value, we turn that into a grayscale color...
                CGContextSetGrayFillColor(context, value, 1.0);
                // ...and fill the appropriate pixel.
                CGRect rect = CGRectMake(x, y, x+1, y+1);
                CGContextFillRect(context, rect);
            } }
        // Once the rendering is done, grab the image from the context
        UIImage* image = UIGraphicsGetImageFromCurrentImageContext();
        // And then call the completion block, making sure
        // to do it on the main queue
        [[NSOperationQueue mainQueue] addOperationWithBlock:^{
            completionBlock(image);
        }];
        // Finally, tidy up by removing the image context // we created.
        UIGraphicsEndImageContext();
    }];
    // We don't return anything in this method because the image
    // is returned to the caller via the completion block.
}

@end
